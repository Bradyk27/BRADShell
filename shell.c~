#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <memory.h>

/*Adapted from T. Ritter's Code*/
/*Signal interrupt handler seems easy enough...let's do that next. Just make a circular buffer and print it out on exit. No problem*/
/*Next need to move to piping--figure out exactly what this is and how it will work*/
/*Also need to determine where and how forking & piping should work, maybe ask Zach for advice on this.*/


/*Above all else, stay calm, think logically, you have plenty of time*/
/*Be confident in yourself, always look to learn, be the man you want to be, once more unto the breach*/


/*Circular Buffer Code Adapted From: http://www.equestionanswers.com/c/c-circular-buffer.php*/

typedef struct sbuff_{
  char* buff;
  int start;
  int end;
  int size;
  int count;
} sbuff_t;

sbuff_t * sbuff_new(int size)
{
  sbuff_t * sb = (sbuff_t*)malloc(sizeof(sbuff_t));
  memset(sb, 0, sizeof(sbuff_t));
  sb->size = size;
  sb->buff = (char*)malloc(sizeof(int)*size);
  
  return sb;
}

void sbuff_add(sbuff_t * sb, char elem)
{
  int end = sb->end;
  if(sb->count && (end % sb->size) == sb->start){
    printf("Overflow Elem[%d] %c lost\n", sb->start, sb->buff[sb->start]);
    sb->start = (sb->start + 1 ) %sb->size;
    sb->count --;
  }
  printf("Added Elem[%d] = %c\n",sb->end, elem);
  sb->buff[sb->end] = elem;
  sb->end = (sb->end+1) % sb->size;
  sb->count ++;
}

int sbuff_remove(sbuff_t * sb)
{
  int start = sb->start ;
  int ret = -1;
  if(sb->count <= 0) {
    printf("Buffer is empty\n");
    return ret;
  }
  if(sb->count || (start % sb->size) != sb->end) {
    printf("Removed Elem[%d] = %d\n",sb->start, sb->buff[sb->start]);
    ret = sb->buff[sb->start];
    sb->start = (sb->start + 1 ) % sb->size;
    sb->count--;
  } else {
    printf("Buffer is empty\n");
  }
  return ret;
}

void sbuff_print(sbuff_t * sb)
{
  int start = sb->start ;
  int end = sb->end ;
  int i, count = 0;
  for(i = start; count < sb->count; i = (i + 1)%sb->size){
    printf("Elem[%d] = %d\n", i, sb->buff[i]);
    count++;
    if(i == (end - 1)) {
      break;
    }
  }
}

void sbuff_delete(sbuff_t * sb)
{
  free(sb->buff);
  free(sb);
}




int main()
{
  int pid;
  char *prompt ="BSHELL> ";
  char line[256];
  char *token;
  char *token2;
  char *token3;
  char *token4;
  char *token5;
  char *token6;
  char *token7;
  char *token8;
  char *token9;
  char *token10;

  sbuff_t *cb = sbuff_new(10);

  fprintf(stderr,"%s",prompt);
  while ( scanf ("%[^\n]%*c",line) != EOF )
    {
      switch(pid=fork())
	{

	case 0:
	  token = strtok(line, " ,.");
	  token2 = strtok(NULL, " ,.");
	  token3 = strtok(NULL, " ,.");
	  token4 = strtok(NULL, " ,.");
	  token5 = strtok(NULL, " ,.");
	  token6 = strtok(NULL, " ,.");
	  token7 = strtok(NULL, " ,.");
	  token8 = strtok(NULL, " ,.");
	  token9 = strtok(NULL, " ,.");
	  token10 = strtok(NULL, " ,.");
	  sbuff_add(cb, line);

	  execlp(line,token, token2, token3, token4, token5, token6, token7, token8, token9, token10, NULL);
	  fprintf(stderr,"ERROR %s no such program\n",line); /*only reaches here is file exec FAILS. Else, it forks*/
	  exit(1);
	  break;

	case -1: fprintf(stderr,"ERROR can't create child process!\n");
	  break;

	default: 
	  wait(NULL);   /* parent waits until child process is finished...apparently */
	  break;
	}
      fprintf(stderr,"%s",prompt); /*Restart the shell*/ 
    }
  exit(0);
}


  
